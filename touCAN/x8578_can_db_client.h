/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 37.2.0 Fri Oct 28 15:47:12 2022.
 */

#ifndef X8578_CAN_DB_CLIENT_H
#define X8578_CAN_DB_CLIENT_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_K_FRAME_ID (0x4e6u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_L_FRAME_ID (0x4e8u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_J_FRAME_ID (0x4e4u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_I_FRAME_ID (0x4e2u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_FRAME_ID (0x2fu)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_FRAME_ID (0x24u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_C_FRAME_ID (0x50u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_FRAME_ID (0x5au)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_G_FRAME_ID (0x5eu)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_FRAME_ID (0x60u)
#define X8578_CAN_DB_CLIENT_UDS_DIAG_RESP_FRAME_ID (0x7efu)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_FRAME_ID (0x12u)
#define X8578_CAN_DB_CLIENT_GWM_PMZ_H_FRAME_ID (0x1b0u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_AC_MHEV_FRAME_ID (0x4au)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_FRAME_ID (0x3cu)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_T_MHEV_FRAME_ID (0x2au)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_U_MHEV_FRAME_ID (0x2du)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_W_MHEV_FRAME_ID (0x3eu)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_X_MHEV_FRAME_ID (0x2c0u)
#define X8578_CAN_DB_CLIENT_UDS_DIAG_FUN_REQ_FRAME_ID (0x7dfu)
#define X8578_CAN_DB_CLIENT_UDS_DIAG_PHY_REQ_FRAME_ID (0x7e7u)
#define X8578_CAN_DB_CLIENT_VEHCONFIG_400_PMZ_AUTO_SAR_FRAME_ID (0x400u)

/* Frame lengths in bytes. */
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_K_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_L_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_J_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_I_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_C_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_G_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_UDS_DIAG_RESP_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_GWM_PMZ_H_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_AC_MHEV_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_T_MHEV_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_U_MHEV_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_W_MHEV_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_X_MHEV_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_UDS_DIAG_FUN_REQ_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_UDS_DIAG_PHY_REQ_LENGTH (8u)
#define X8578_CAN_DB_CLIENT_VEHCONFIG_400_PMZ_AUTO_SAR_LENGTH (8u)

/* Extended or standard frame types. */
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_K_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_L_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_J_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_I_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_C_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_G_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_UDS_DIAG_RESP_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_GWM_PMZ_H_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_AC_MHEV_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_T_MHEV_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_U_MHEV_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_W_MHEV_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_X_MHEV_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_UDS_DIAG_FUN_REQ_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_UDS_DIAG_PHY_REQ_IS_EXTENDED (0)
#define X8578_CAN_DB_CLIENT_VEHCONFIG_400_PMZ_AUTO_SAR_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_K_CYCLE_TIME_MS (10u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_L_CYCLE_TIME_MS (10u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_J_CYCLE_TIME_MS (10u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_I_CYCLE_TIME_MS (10u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_CYCLE_TIME_MS (10u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_C_CYCLE_TIME_MS (10u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_CYCLE_TIME_MS (10u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_G_CYCLE_TIME_MS (10u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_CYCLE_TIME_MS (10u)

/* Signal choices. */
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_ENGINE_TORQ_ACT_QF_ACCURACY_OF_DATA_IS_UNDEFINABLE_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_ENGINE_TORQ_ACT_QF_EVALUATION_IN_PROGRESS_CHOICE (1u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_ENGINE_TORQ_ACT_QF_ACCURACY_OF_DATA_NOT_WITHIN_SPEC_CHOICE (2u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_ENGINE_TORQ_ACT_QF_CALCULATED_WITH_SPECIFIC_ACC_CHOICE (3u)

#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_K0_MODE_REQUEST_K0__DISCONNECT__ENGINE__OFF_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_K0_MODE_REQUEST_K0__DISCONNECT__ENGINE__ON_CHOICE (1u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_K0_MODE_REQUEST_K0__CONNECT__ENGINE__OFF_CHOICE (2u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_K0_MODE_REQUEST_K0__CONNECT__ENGINE__ON_CHOICE (3u)

#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_ENGINE_START_TORQUE_INITIALISATION_CHOICE (254u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_ENGINE_START_TORQUE_FAILURE_CHOICE (255u)

#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_DRVLINE_DAMP_ENBL_FLG_MD1_DISABLED_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_DRVLINE_DAMP_ENBL_FLG_MD1_ENABLED_CHOICE (1u)

#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_INITIALISATION_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_1_CHOICE (1u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_2_CHOICE (2u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_3_CHOICE (3u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_4_CHOICE (4u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_5_CHOICE (5u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_6_CHOICE (6u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_7_CHOICE (7u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_8_CHOICE (8u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_9_CHOICE (9u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_10_CHOICE (10u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_11_CHOICE (11u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_12_CHOICE (12u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_13_CHOICE (13u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_14_CHOICE (14u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_15_CHOICE (15u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_VARIANT_16_CHOICE (16u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_V_MHEV_SLIP_START_TYPE_REQUEST_FAILURE_CHOICE (31u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_INVERTER_TEMPERATURE_INITIALISATION_CHOICE (254u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_INVERTER_TEMPERATURE_FAILURE_CHOICE (255u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_INVERTER_HVIL_STATUS_HVIL_OK_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_INVERTER_HVIL_STATUS_HVIL_NOT_OK_CHOICE (1u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_INVERTER_HVIL_STATUS_HVIL_NOT_CHECKED_CHOICE (2u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_INVERTER_HVIL_STATUS_RESERVED_CHOICE (3u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_INV_ACTIVE_SHORT_CIRCUIT_ACTIVE__SHORT__CIRCUIT__OFF_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_INV_ACTIVE_SHORT_CIRCUIT_ACTIVE__SHORT__CIRCUIT__ON_CHOICE (1u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EPIC_PUMP_DIAG_STATUS_PUMP_OK_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EPIC_PUMP_DIAG_STATUS_PUMP__NOT_OK_CHOICE (1u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EPIC_CHRG_EM_PUMP_DIAG_STAT_PUMP_OK_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EPIC_CHRG_EM_PUMP_DIAG_STAT_PUMP__NOT__OK_CHOICE (1u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_VOLTAGE_DC_LINK_INITIALISATION__CHOICE (1022u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_VOLTAGE_DC_LINK_FAILURE_CHOICE (1023u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_STANDBY_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_TORQUE__MODE_CHOICE (1u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_RESERVED___SPEED__MODE__CHOICE (2u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_VOLTAGE__MODE_CHOICE (3u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_BUS__TEST__MODE_CHOICE (4u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_NOT__CAPABLE_CHOICE (5u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_RESERVED___CALIBRATION__MODE__CHOICE (6u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_RESERVED___BUS__DISCHARGE__MODE__CHOICE (7u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_LIFE__SAVER__MODE_CHOICE (8u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_PRE__LOAD__MODE_CHOICE (9u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_UNUSED_10_CHOICE (10u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_UNUSED_11_CHOICE (11u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_UNUSED_12_CHOICE (12u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_FAILURE_HV__NOT__ALLOWED_CHOICE (13u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_INITIALISATION_CHOICE (14u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EM_OPERATING_MODE_EXT_FAILURE_CHOICE (15u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EMACOC_MONITOR_STATUS_OK_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_EMACOC_MONITOR_STATUS_NOT__OK_CHOICE (1u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_RAPID_DSCHRG_DIAG_STATUS_OK_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_A_RAPID_DSCHRG_DIAG_STATUS_NOT__OK_CHOICE (1u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_C_EM_SPEED_QF_ACCURACY_OF_DATA_IS_UNDEFINABLE_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_C_EM_SPEED_QF_EVALUATION_IN_PROGRESS_CHOICE (1u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_C_EM_SPEED_QF_ACCURACY_IS_NOT_WITHIN_SPEC_CHOICE (2u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_C_EM_SPEED_QF_IN_THE_SPECIFIED_ACCURACY_CHOICE (3u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_C_EM_SPEED_INITIALISATION_CHOICE (32766u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_C_EM_SPEED_FAILURE_CHOICE (32767u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_EM_CURRENT_DC_LINK_INITIALISATION_CHOICE (4094u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_EM_CURRENT_DC_LINK_FAILURE_CHOICE (4095u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_TOC_PUMP_DIAG_STATUS_PUMP_OK_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_TOC_PUMP_DIAG_STATUS_PUMP__NOT__OK_CHOICE (1u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_INV_START_CURRENT_DERATE_NOT_CURRENT_DERATING_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_INV_START_CURRENT_DERATE_DERATING__START__CURRENT_CHOICE (1u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_INV_SHORT_TIME_CUR_DERATE_NOT_CURRENT_DERATING_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_INV_SHORT_TIME_CUR_DERATE_DERATING__SHORT__TIME__OVERLOAD__CURRENT_CHOICE (1u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_EPICMIL_REQUEST_NO_MIL__REQUEST_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_EPICMIL_REQUEST_REQUEST_MIL_ON_CHOICE (1u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_EPICMIL_REQUEST_REQUEST_MIL__FLASHING_CHOICE (2u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_EPICMIL_REQUEST_RESERVED__NOT_USED_CHOICE (3u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_EM_PUMP_DIAG_STATUS_PUMP_OK_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_EM_PUMP_DIAG_STATUS_PUMP__NOT_OK_CHOICE (1u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_INV_TEMPERATURE_DERATE_NOT__TEMPERATURE_DERATING_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_INV_TEMPERATURE_DERATE_TEMPERATURE_DERATING_CHOICE (1u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_EM_TEMPERATURE_INITIALISATION_CHOICE (510u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_E_EM_TEMPERATURE_FAILURE_CHOICE (511u)

#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_STANDBY_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_TORQUE__MODE_CHOICE (1u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_SPEED__MODE_CHOICE (2u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_VOLTAGE__MODE_CHOICE (3u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_BUS__TEST__MODE_CHOICE (4u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_NOT__CAPABLE_CHOICE (5u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_RESERVED___CALIBRATION__MODE__CHOICE (6u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_BUS__DISCHARGE_MODE_CHOICE (7u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_LIFE__SAVER__MODE_CHOICE (8u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_PRE__LOAD__MODE_CHOICE (9u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_PRE_FLUX__MODE_CHOICE (10u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_ENGINE__STOP__ASSIST___ESA_CHOICE (11u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_UNUSED_CHOICE (12u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_FAILURE_HV__NOT__ALLOWED_CHOICE (13u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_INITIALISATION_CHOICE (14u)
#define X8578_CAN_DB_CLIENT_EPIC_PMZ_H_EM_OPERATING_MODE_EXT2_FAILURE_CHOICE (15u)

#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_CAR_MODE_HS_NORMAL_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_CAR_MODE_HS_FACTORY_CHOICE (1u)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_CAR_MODE_HS_UNUSED_2_CHOICE (2u)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_CAR_MODE_HS_TRANSPORT_CHOICE (3u)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_CAR_MODE_HS_UNUSED_4_CHOICE (4u)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_CAR_MODE_HS_CRASH_CHOICE (5u)

#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_POWER_MODE_KEY_OUT_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_POWER_MODE_KEY_RECENTLY_OUT_CHOICE (1u)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_POWER_MODE_KEY_APPROVED_0_CHOICE (2u)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_POWER_MODE_POST_ACCESSORY_0_CHOICE (3u)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_POWER_MODE_ACCESSORY_1_CHOICE (4u)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_POWER_MODE_POST_IGNITION_1_CHOICE (5u)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_POWER_MODE_IGNITION_ON_2_CHOICE (6u)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_POWER_MODE_RUNNING_2_CHOICE (7u)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_POWER_MODE___NOT_USED__CHOICE (8u)
#define X8578_CAN_DB_CLIENT_BCM_PMZ_A_POWER_MODE_CRANK_3_CHOICE (9u)

#define X8578_CAN_DB_CLIENT_GWM_PMZ_H_CRASH_STATUS_RCM_NO_CRASH_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_GWM_PMZ_H_CRASH_STATUS_RCM_CRASH_CONDITION_CHOICE (1u)

#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_STANDBY_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_TORQUE__MODE_CHOICE (1u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_RESERVED___SPEED__MODE__CHOICE (2u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_VOLTAGE__MODE_CHOICE (3u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_BUS__TEST__MODE_CHOICE (4u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_UNUSED_5_CHOICE (5u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_RESERVED___CALIBRATION__MODE__CHOICE (6u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_RESERVED___BUS__DISCHARGE__MODE__CHOICE (7u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_LIFE__SAVER__MODE_CHOICE (8u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_PREFLUX__MODE_CHOICE (9u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_ENGINE__STOP__ASSIST__MODE___ESA_CHOICE (10u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_UNUSED_11_CHOICE (11u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_UNUSED_12_CHOICE (12u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_UNUSED_13_CHOICE (13u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_UNUSED_14_CHOICE (14u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_OPERATING_MODE_REQ_EXT_UNUSED_15_CHOICE (15u)

#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_VOLTAGE_DC_LINK_REQ_EXT_INITIALISATION_CHOICE (1022u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_VOLTAGE_DC_LINK_REQ_EXT_FAILURE_CHOICE (1023u)

#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_SPEED_REQUEST_EXT_INITIALISATION_CHOICE (32766u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_F_HYBRID_EM_SPEED_REQUEST_EXT_FAILURE_CHOICE (32767u)

#define X8578_CAN_DB_CLIENT_PCM_PMZ_T_MHEV_EM_COOLANT_PUMP_DR_REQ_FAILURE_CHOICE (127u)

#define X8578_CAN_DB_CLIENT_PCM_PMZ_T_MHEV_EM_CUR_DC_LINK_GEN_LIMIT_INITIALISATION_CHOICE (510u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_T_MHEV_EM_CUR_DC_LINK_GEN_LIMIT_FAILURE_CHOICE (511u)

#define X8578_CAN_DB_CLIENT_PCM_PMZ_T_MHEV_EM_VOL_DC_LINK_GEN_LIMIT_INITIALISATION_CHOICE (1022u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_T_MHEV_EM_VOL_DC_LINK_GEN_LIMIT_FAILURE_CHOICE (1023u)

#define X8578_CAN_DB_CLIENT_PCM_PMZ_U_MHEV_EM_TORQUE_MIN_LIMIT_INITIALISATION_CHOICE (1022u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_U_MHEV_EM_TORQUE_MIN_LIMIT_FAILURE_CHOICE (1023u)

#define X8578_CAN_DB_CLIENT_PCM_PMZ_U_MHEV_EM_TORQUE_MAX_LIMIT_INITIALISATION_CHOICE (1022u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_U_MHEV_EM_TORQUE_MAX_LIMIT_FAILURE_CHOICE (1023u)

#define X8578_CAN_DB_CLIENT_PCM_PMZ_W_MHEV_BISG_CALIBRATION_ID_REQ_NOT__ACTIVE_CHOICE (0u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_W_MHEV_BISG_CALIBRATION_ID_REQ_ACTIVE_CHOICE (1u)

#define X8578_CAN_DB_CLIENT_PCM_PMZ_W_MHEV_EM_CUR_DC_LINK_MOTOR_LIMIT_INITIALISATION_CHOICE (510u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_W_MHEV_EM_CUR_DC_LINK_MOTOR_LIMIT_FAILURE_CHOICE (511u)

#define X8578_CAN_DB_CLIENT_PCM_PMZ_W_MHEV_EM_VOL_DC_LINK_MOTOR_LIMIT_INITIALISATION_CHOICE (1022u)
#define X8578_CAN_DB_CLIENT_PCM_PMZ_W_MHEV_EM_VOL_DC_LINK_MOTOR_LIMIT_FAILURE_CHOICE (1023u)

/**
 * Signals in message EPIC_PMZ_K.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_epic_pmz_k_t {
    /**
     * Sporadic Signal  - Calibration Identification for the software installed on the ECU. Format is 16 character 128 bit ASCII ($20 through $7E). This signal comprises characters 9 to 16 of 16 characters.
     *
     * Range: 0..72057594037927900 (0..7.20575940379279E+16 -)
     * Scale: 1
     * Offset: 0
     */
    uint64_t bisg_calibration_id02;
};

/**
 * Signals in message EPIC_PMZ_L.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_epic_pmz_l_t {
    /**
     * Sporadic Signal  - Number used to verify the integrity of the vehicle software. Consists of four Bytes values interpreted as Hexadecimal eg 0B 9F 4E D5
     *
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t bisg_calib_verif_number;
};

/**
 * Signals in message EPIC_PMZ_J.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_epic_pmz_j_t {
    /**
     * Sporadic Signal  - Calibration Identification for the software installed on the ECU. Format is 16 character 128 bit ASCII ($20 through $7E) Each character is 7 bits and is split over two messages. This signal comprises characters 1 to 8 of 16 characters.
     *
     * Range: 0..72057594037927900 (0..7.20575940379279E+16 -)
     * Scale: 1
     * Offset: 0
     */
    uint64_t bisg_calibration_id01;
};

/**
 * Signals in message EPIC_PMZ_I.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_epic_pmz_i_t {
    /**
     * Bit coded Diagnostic message contained in a single CAN signal. Periodically broadcast by component to the Diagnostic Service Manager
     * 
     *
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t bisg_diagnostic01;
};

/**
 * Signals in message PCM_PMZ_V_MHEV.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_pcm_pmz_v_mhev_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t engine_torq_act_qf;

    /**
     * Hybrid Systems = Request to the TCM to engage and disengage K0 Clutch
     * 
     * Non-Hybrid Systems = Request to the TCM to enagage and disengage Gliding Clutch
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t k0_mode_request;

    /**
     * Range: 0..255 (0..255 Nm)
     * Scale: 1
     * Offset: 0
     */
    uint8_t engine_start_torque;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t drvline_damp_enbl_flg_md1;

    /**
     * Range: 0..15 (0..15 N = E (modulo 16). One increment)
     * Scale: 1
     * Offset: 0
     */
    uint8_t engine_torq_counter;

    /**
     * Range: 0..2047 (-1023..1024 Nm)
     * Scale: 1
     * Offset: -1023
     */
    uint16_t engine_torq_act;

    /**
     * Range: 0..255 (0..255 checksum)
     * Scale: 1
     * Offset: 0
     */
    uint8_t engine_torq_checksum;

    /**
     * Range: 17..30 (17..30 Not used)
     * Scale: 1
     * Offset: 0
     */
    uint8_t slip_start_type_request;

    /**
     * Range: 0..2047 (-1023..1024 Nm)
     * Scale: 1
     * Offset: -1023
     */
    uint16_t engine_torq_tgt_wo_trans;
};

/**
 * Signals in message EPIC_PMZ_A.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_epic_pmz_a_t {
    /**
     * Temperature of the ACDC Inverter
     *
     * Range: 0..253 (-40..213 %)
     * Scale: 1
     * Offset: -40
     */
    uint8_t inverter_temperature;

    /**
     * Status of the EPIC Inverter Hazardous Voltage Interlock Loop.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_hvil_status;

    /**
     * ACDC Inverter Active Short Circuit function status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inv_active_short_circuit;

    /**
     * Inverter and DCDC Converter coolant pump diagnostic status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t epic_pump_diag_status;

    /**
     * Inverter/DCDC, Charger & EM coolant pump diagnostic status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t epic_chrg_em_pump_diag_stat;

    /**
     * High Voltage DC Bus Voltage measured at the Electric Machine Inverter.
     *
     * Range: 0..1021 (0..1021 Volts)
     * Scale: 1
     * Offset: 0
     */
    uint16_t em_voltage_dc_link;

    /**
     * Electrical Machine operating mode
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_operating_mode_ext;

    /**
     * Used to ensure that the EPIC is still in active communications with its Micro controller.
     * 
     * Value to increment with each new message sent.
     * 
     * Value initialises at 0 and Increases to 15 at which point the signal is reset to 0 and begins counting up again.
     * 
     * Value initialises to 0.
     * 
     * Stuck count also indicates a fault.
     *
     * Range: 0..15 (0..15 Counter value)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_op_mode_ext_gp_counter;

    /**
     * The status of the EPIC's open circuit monitor for the HV AC Bus.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t emacoc_monitor_status;

    /**
     * Status of the HV DC bus rapid discharge mechanism
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rapid_dschrg_diag_status;

    /**
     * High voltage DC bus voltage measured at the electric machine inverter.
     *
     * Range: 0..1023 (0..1023 Volts)
     * Scale: 1
     * Offset: 0
     */
    uint16_t em_voltage_dc_link_ext;

    /**
     * Signals contained in SAE J1850 CRC8 Checksum: EMOperatingModeExt,
     * EMVoltageDCLinkExt, EMACOCMonitorStatus, RapidDschrgDiagStatus,
     * EMOpModeExtGpCounter .
     * 
     * The calculation method is specified in STJLR 18.036.
     * Signals used in the calculation must be in the same message frame.
     * 
     * The Data Segment Polynomial shall be assembled as follows, with offsets in Motorola
     * Backwards notation :-
     * 
     * Byte 1 is the leftmost byte in SAEJ1850 Table 1.
     * 
     * Byte 1
     * Signal marker Signal name                                                     Offset
     * =========== ==========                                                   =====
     * A 	           EMVoltageDCLinkExt (Most significant 8 bits) 0
     * 
     * Byte 2
     * Signal marker Signal name                                                     Offset
     * =========== ==========                                                   =====
     * B                     RapidDschrgDiagStatus                                    0
     * C                     EMACOCMonitorStatus                                    1
     * D
     *
     * Range: 0..255 (0..255 checksum)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_op_mode_ext_gp_cs;
};

/**
 * Signals in message EPIC_PMZ_C.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_epic_pmz_c_t {
    /**
     * Quality Factor for the Speed of the Electric Machine.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_speed_qf;

    /**
     * Used to ensure that the Inverter is still in active communications with its Micro controller.
     * 
     * Value to increment with each new message sent.
     * 
     * Value initialises at 0 and increases to 15 at which point the signal is reset to 0 and begins counting up again.
     * 
     * Value initialises to 0.
     * 
     * Stuck count also indicates a fault.
     *
     * Range: 0..15 (0..15 N = E (modulo 16). One increment)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_torq_speed_ext_gp_counter;

    /**
     * The additional torque scheduled by the Inverter for driveline damping
     *
     * Range: 0..2047 (-102.3..102.4 Nm)
     * Scale: 0.1
     * Offset: -102.3
     */
    uint16_t drvline_damp_torque_delta;

    /**
     * Speed of the Electric Machine
     * (Hybrid Specific Signal)
     *
     * Range: 0..32765 (-16382..16383 RPM)
     * Scale: 1
     * Offset: -16382
     */
    uint16_t em_speed;

    /**
     * Signals contained in SAE J1850 CRC8 Checksum: EMSpeed, EMSpeedQF, EMTorqueExt,
     * DrvlineDampTorqueDelta, EMTorqSpeedExtGpCounter.
     * The calculation method is specified in STJLR 18.036.
     * Signals used in the calculation must be in the same message frame.
     * The Data Segment Polynomial shall be assembled as follows, with offsets in Motorola Backwards notation :-
     * Byte 1 is the leftmost byte in SAEJ1850 Table 1.
     * Byte 1
     * Signal marker Signal name Offset
     * =========== ========== =====
     * A DrvlineDampTorqueDelta (Most significant 8 bits) 0
     * Byte 2
     * Signal marker Signal name Offset
     * =========== ========== =====
     * B EMSpeedQF 0
     * 0 3 padding bit of zero 2
     * C DrvlineDampTorqueDelta (Least significant 3 bits) 5
     * Byte 3
     * Signal marker Signal name Offset
     * =========== ========== =====
     * D EMSpeed (Most significant 7 bits) 0
     * 0 1 padding bit of zero 7
     * Byte 4
     * Signal marker Signal name Offset
     * =========== ========== =====
     * E EMSpeed (Least significant 8 bits) 0
     * Byte 5
     * Signal marker Signal name Offset
     * =========== ========== ====
     *
     * Range: 0..255 (0..255 checksum)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_torq_speed_ext_gp_cs;

    /**
     * Torque of the EM machine without inertial compensation
     * (Hybrid Specific Signal)
     * 
     * Note: More precise version of the EMTorque signal.
     *
     * Range: 0..32767 (-1638.3..1638.4 Nm)
     * Scale: 0.1
     * Offset: -1638.3
     */
    uint16_t em_torque_ext;
};

/**
 * Signals in message EPIC_PMZ_E.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_epic_pmz_e_t {
    /**
     * High Voltage DC Bus current measured at the Electrical Machine Inverter
     * Positive - Motoring Mode
     * Negative - Generating Mode
     *
     * Range: 0..4093 (-511.5..511.75 Amps)
     * Scale: 0.25
     * Offset: -511.5
     */
    uint16_t em_current_dc_link;

    /**
     * Transmission Oil Coolant (TOC) coolant pump diagnostic status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t toc_pump_diag_status;

    /**
     * ACDC Inverter start current derate status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inv_start_current_derate;

    /**
     * ACDC Inverter short time current derate status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inv_short_time_cur_derate;

    /**
     * MIL request signal required to be raised by EPIC module and received by PCM. This is necessary in order to comply with the OBDII requirement for NAS market.
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t epicmil_request;

    /**
     * Electrical Machine coolant pump diagnostic status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_pump_diag_status;

    /**
     * ACDC Inverter temperarture derate status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inv_temperature_derate;

    /**
     * Coil temperature of the Electrical Machine
     * 
     * For PHEV:
     * Temperature of the Electric Machine's Stator
     *
     * Range: 0..509 (-40..469 degC)
     * Scale: 1
     * Offset: -40
     */
    uint16_t em_temperature;

    /**
     * Temperature of the Electric Machine's Rotor
     *
     * Range: 0..511 (-40..471 deg C)
     * Scale: 1
     * Offset: -40
     */
    uint16_t em_rotor_temperature;

    /**
     * Rate of change of Electric Machine temperature (warning of change of Max / Min limits)
     *
     * Range: 0..120 (0..120 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t temperature_rate;
};

/**
 * Signals in message EPIC_PMZ_G.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_epic_pmz_g_t {
    /**
     * Signals contained in SAE J1850 CRC8 Checksum: EMMaxTorqueLimit, EMMinTorqueLimit,
     * EMMinContTorqueLimit, EMMaxContTorqueLimit, EMTorqLimitGpCounter .
     * The calculation method is specified in STJLR 18.036.
     * Signals used in the calculation must be in the same message frame.
     * The Data Segment Polynomial shall be assembled as follows, with offsets in Motorola
     * Backwards
     * notation :-
     * Byte 1 is the leftmost byte in SAEJ1850 Table 1.
     * Byte 1
     * Signal marker Signal name Offset
     * =========== ========== =====
     * A EMMaxTorqueLimit (Most significant 8 bits) 0
     * Byte 2
     * Signal marker Signal name Offset
     * =========== ========== =====
     * B EMMinTorqueLimit (Most significant 2 bits) 0
     * C EMTorqLimitGpCounter 2
     * D EMMaxTorqueLimit (Least significant 2 bits) 6
     * Byte 3
     * Signal marker Signal name Offset
     * =========== ========== =====
     * E EMMinTorqueLimit (Least significant 8 bits) 0
     * Byte 4
     * Signal marker Signal name Offset
     * =========== ========== =====
     * F EMMaxContTorqueLimit (Most significant 8 bits) 0
     * Byte 5
     * Signal marker Signal na
     *
     * Range: 0..255 (0..255 checksum)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_torq_limit_gp_cs;

    /**
     * Used to ensure that the Inverter is still in active communications with its Micro controller.
     * 
     * Value to increment with each new message sent.
     * 
     * Value initialises at 0 and Increases to 15 at which point the signal is reset to 0 and begins counting up again.
     * 
     * Value initialises to 0.
     * 
     * Stuck count also indicates a fault.
     *
     * Range: 0..15 (0..15 N = E (modulo 16). One increment)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_torq_limit_gp_counter;

    /**
     * Instantaneous Minimum torque available from the Electric Machine�in 'Torque Control' Mode.
     *
     * Range: 0..1023 (-1023..0 Nm)
     * Scale: 1
     * Offset: -1023
     */
    uint16_t em_min_torque_limit;

    /**
     * Continuous Minimum torque available from the Electric Machine�in 'Torque Control' Mode.
     *
     * Range: 0..1023 (-1023..0 Nm)
     * Scale: 1
     * Offset: -1023
     */
    uint16_t em_min_cont_torque_limit;

    /**
     * Instantaneous Maximum torque available from the Electric Machine�in 'Torque Control' Mode.
     *
     * Range: 0..1023 (0..1023 Nm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t em_max_torque_limit;

    /**
     * Continuous Maximum torque available from the Electric Machine�in 'Torque Control' Mode.
     *
     * Range: 0..1023 (0..1023 Nm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t em_max_cont_torque_limit;
};

/**
 * Signals in message EPIC_PMZ_H.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_epic_pmz_h_t {
    /**
     * MHEV DC Bus Voltage measured at the Electric Machine Inverter.
     *
     * Range: 0..1023 (0..102.3 Volts)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t em_voltage_dc_link_mv;

    /**
     * Group:  EMOpModeMVGp	Checksum: EMOpModeMVGpCS
     * 
     * Signals contained in SAE J1850 CRC8 Checksum: EMVoltageDCLinkMV, EMOperatingModeExt2, EMOpModeMVGpCounter, BISGSpeed
     * 
     * The calculation method is specified in STJLR 18.036.
     * Signals used in the calculation must be in the same message frame.
     * The Data Segment Polynomial shall be assembled as follows, with offsets in Motorola
     * Backwards notation:-
     * 
     * Byte 1
     * Signal marker 	Signal name 						Offset
     * ========== 	========== =========================		=====
     * A		EMVoltageDCLinkMV	(most significant 8 bits)		0
     * 
     * Byte 2
     * Signal marker 	Signal name 						Offset
     * ========== 	========== =========================		=====
     * B 		EMOperatingModeExt2 			(4 bits)		0
     * C		EMVoltageDCLinkMV	(least significant 2 bits)		4
     * 0		Two padding bits of zero		(4 bits)		6
     * 
     * Byte 3
     * Signal marker 	Signal name 						Offset
     * ========== 	========== =========================		=====
     * D 		BISGSpeed		(most significant 8 bits)		0
     * 
     * 
     * Byte4
     * Signal marker 	Signal name 						Offset
     * ========== 	======
     *
     * Range: 0..255 (0..255 checksum)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_op_mode_mv_gp_cs;

    /**
     * Electrical Machine operating mode
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_operating_mode_ext2;

    /**
     * Used to ensure that the BISG is still in active communications with its Micro controller.
     * 
     * 
     * 
     * Value to increment with each new message sent.
     * 
     * 
     * 
     * Value initialises at 0 and Increases to 15 at which point the signal is reset to 0 and begins counting up again.
     * 
     * 
     * 
     * Value initialises to 0.
     * 
     * Stuck count also indicates a fault.
     *
     * Range: 0..15 (0..15 N = E (modulo 16). One increment)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_op_mode_mv_gp_counter;

    /**
     * Speed of the BISG.
     *
     * Range: 0..65535 (-32767..32768 RPM)
     * Scale: 1
     * Offset: -32767
     */
    uint16_t bisg_speed;
};

/**
 * Signals in message UDS_DIAG_Resp.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_uds_diag_resp_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t dummy_signal;
};

/**
 * Signals in message BCM_PMZ_A.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_bcm_pmz_a_t {
    /**
     * Information about which Carmode the vehicle is in i.e. Normal, factory etc.
     *
     * Range: 6..15 (6..15 Unused)
     * Scale: 1
     * Offset: 0
     */
    uint8_t car_mode_hs;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t car_mode_hs_ub;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t power_mode_ub;

    /**
     * Information of current PowerMode, reflects the current  state of the Power Mode Superviser
     * 
     * For L538:
     * The signals PowerModeHS, PowerModeHSQF & PowerModeComp are all with the group PowerModeGrpHS. This grouping is to ensure that the signals are packed within the same frame, they are not treated as a group within the BCM.
     *
     * Range: 10..31 (10..31 Not Used)
     * Scale: 1
     * Offset: 0
     */
    uint8_t power_mode;
};

/**
 * Signals in message GWM_PMZ_H.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_gwm_pmz_h_t {
    /**
     * This signal defines the crash status of the vehicle safety system.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t crash_status_rcm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t crash_status_rcm_ub;
};

/**
 * Signals in message PCM_PMZ_AC_MHEV.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_pcm_pmz_ac_mhev_t {
    /**
     * Requested DC link voltage value in Electric Machine 'Voltage control' mode
     *
     * Range: 0..1023 (0..102.3 Volts)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t em_voltage_dc_link_req_mv;
};

/**
 * Signals in message PCM_PMZ_F_Hybrid.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_pcm_pmz_f_hybrid_t {
    /**
     * Signals contained in SAE J1850 CRC8 Checksum: EMOperatingModeReqExt,
     * EMSpeedRequest, EMVoltageDCLinkRequest, EMTorqueRequestExt,
     * VSCEMReqGpCounter
     * The calculation method is specified in STJLR 18.036.
     * Signals used in the calculation must be in the same message frame.
     * The Data Segment Polynomial shall be assembled as follows, with offsets in Motorola
     * Backwards notation :-
     * Byte 1 is the leftmost byte in SAEJ1850 Table 1.
     * Byte 1
     * Signal marker  Signal name          Offset
     * =========== ========== =====
     * A                        EMSpeedRequest  (Most significant 8 bits) 0
     * Byte 2
     * Signal marker Signal name Offset
     * =========== ========== =====
     * 0 1 padding bit of zero 0
     * B EMSpeedRequest (Least significant 7 bits) 1
     * Byte 3
     * Signal marker Signal name Offset
     * =========== ========== =====
     * C EMTorqueRequestExt (Most significant 8 bits) 0
     * Byte 4
     * Signal marker Signal name Offset
     * =========== ========== =====
     * 0 1 padding bit of zero 0
     * D EMTorqueRequestExt (Least significant 7 bits) 1
     * Byte 5
     * Signal marker S
     *
     * Range: 0..255 (0..255 checksum)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vscem_req_gp_cs;

    /**
     * Initilalised to zero, increments from 0 to 15
     *
     * Range: 0..15 (0..15 Counter value)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vscem_req_gp_counter;

    /**
     * Electrical Machine (ACDC) operating mode request
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_operating_mode_req_ext;

    /**
     * Requested DC link voltage value in Electric Machine 'Voltage control' mode
     *
     * Range: 0..1021 (0..1021 Volts)
     * Scale: 1
     * Offset: 0
     */
    uint16_t em_voltage_dc_link_req_ext;

    /**
     * Requested Electric machine speed value in 'Speed control mode'
     *
     * Range: 0..32765 (-16382..16383 rpm)
     * Scale: 1
     * Offset: -16382
     */
    uint16_t em_speed_request_ext;

    /**
     * Torque request for the electrical machine. Positive for motoring, negative for generating
     * (Hybrid Specific Signal)
     * 
     * Note: More precise version of the EMTorqueRequest signal.
     *
     * Range: 0..32767 (-1638.3..1638.4 Nm)
     * Scale: 0.1
     * Offset: -1638.3
     */
    uint16_t em_torque_request_ext;
};

/**
 * Signals in message PCM_PMZ_T_MHEV.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_pcm_pmz_t_mhev_t {
    /**
     * Coolant pump duty ratio request as percentage of maximum for the Transmissions Oil Coolant Loop
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t toc_pump_dr_req;

    /**
     * Electric Machine coolant pump duty ratio request as percentage of maximum
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_coolant_pump_dr_req;

    /**
     * Instantaneous minimum DC Link current that can be supplied during generating mode derived from battery power limits, not to overload HV battery in generating mode. Current is negative in generating mode.
     *
     * Range: 0..509 (-509..0 Amps)
     * Scale: 1
     * Offset: -509
     */
    uint16_t em_cur_dc_link_gen_limit;

    /**
     * Signals contained in SAE J1850 CRC8 Checksum: EMCurDcLinkGenLimit,  EMVolDcLinkGenLimit and EMGenLimitGrpCounter.
     * 
     * Signals used in the calculation must be in the same message frame.
     * 
     * The Data Segment Polynomial shall be assembled as follows, with offsets in Motorola Backwards notation :-
     * Byte 1 is the leftmost byte in SAEJ1850 Table 1.
     * 
     * Byte 1
     * 
     * Signal marker         Signal name             Offset
     * ===========        ==========            =====
     * A                        EMCurDcLinkGenLimit        0 (most significant 8 bits)
     * 
     * Byte 2
     * 
     * Signal marker         Signal name                                                         Offset
     * ===========        ==========                                                        =====
     * A                        EMCurDcLinkGenLimit (least significant 1 bit)    7
     * B                        EMGenLimitGrpCounter.                                              3
     * C                        EMVolDcLinkGenLimit (most significant 3 bits)   0
     * 
     * Byte 3
     * Signal marker         Si
     *
     * Range: 0..255 (0..255 checksum)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_gen_limit_grp_cs;

    /**
     * Used to ensure that the PCM is still in active communications with its Micro controller.
     * 
     * Value to increment with each new message sent.
     * 
     * Value initialises at 0 and Increases to 15 at which point the signal is reset to 0 and begins counting up again.
     * 
     * Value initialises to 0.
     * 
     * Stuck count also indicates a fault.
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_gen_limit_grp_counter;

    /**
     * Instantaneous maximum DC Link voltage allowed in generating mode so as not to exceed the HV battery high voltage limit
     *
     * Range: 0..1021 (0..1021 Volts)
     * Scale: 1
     * Offset: 0
     */
    uint16_t em_vol_dc_link_gen_limit;
};

/**
 * Signals in message PCM_PMZ_U_MHEV.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_pcm_pmz_u_mhev_t {
    /**
     * Range: 0..15 (0..15 Counter value)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vscem_torq_lim_gp_counter;

    /**
     * Minimum allowed Electric Machine torque in generator mode used only for Voltage and Speed control modes. Generating torque is negative.
     *
     * Range: 0..1021 (-1021..0 Nm)
     * Scale: 1
     * Offset: -1021
     */
    uint16_t em_torque_min_limit;

    /**
     * Maximum allowed Electric Machine torque in motor mode used only for Voltage and Speed control modes. Motoring torque is positive.
     *
     * Range: 0..1021 (0..1021 Nm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t em_torque_max_limit;

    /**
     * Minimum allowable Electric Machine modulation torque that can be used during Driveline Damping.
     * Modulated torque limit relative to the EMTorqueRequestExt rather than an absolute value.
     *
     * Range: 0..1023 (-102.3..0 Nm)
     * Scale: 0.1
     * Offset: -102.3
     */
    uint16_t drvline_damp_torq_min_lim;

    /**
     * Maximum allowable Electric Machine modulation torque that can be used during Driveline Damping.
     * Modulated torque limit relative to the EMTorqueRequestExt rather than an absolute value.
     *
     * Range: 0..1023 (0..102.3 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t drvline_damp_torq_max_lim;

    /**
     * Signals contained in SAE J1850 CRC8 Checksum: EMTorqueMaxLimit , EMTorqueMinLimit , DrvlineDampTorqMaxLim , DrvlineDampTorqMinLim , VSCEMTorqLimGpCounter .
     * The calculation method is specified in STJLR 18.036. Signals used in the calculation must be in the same message frame. The Data Segment Polynomial shall be assembled as follows, with offsets in Motorola Backwards notation :-
     * Byte 1 is the leftmost byte in SAEJ1850 Table 1. Byte 1 Signal marker Signal name Offset =========== ========== ===== A EMTorqueMaxLimit (Most significant 8 bits) 0
     * Byte 2 Signal marker Signal name Offset =========== ========== ===== B EMTorqueMinLimit (Most significant 2 bits) 0 C VSCEMTorqLimGpCounter 2 D EMTorqueMaxLimit (Least significant 2 bits) 6
     * Byte 3 Signal marker Signal name Offset =========== ========== ===== E EMTorqueMinLimit (Least significant 8 bits) 0
     * Byte 4 Signal marker Signal name Offset =========== ========== ===== F DrvlineDampTorqMaxLim (Most significant 8 bits) 0
     * Byte 5 Signal marker Signal name Offset ==
     *
     * Range: 0..255 (0..255 checksum)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vscem_torq_lim_gp_cs;
};

/**
 * Signals in message PCM_PMZ_W_MHEV.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_pcm_pmz_w_mhev_t {
    /**
     * Sporadic Signal PCM Diagnostic request to BISG to send the Calibration Verification Number (CVN) and Calibration Identification
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bisg_calibration_id_req;

    /**
     * Positive Torque Gradient for BISG
     *
     * Range: 0..127 (0..1270 Nm/s)
     * Scale: 10
     * Offset: 0
     */
    uint8_t em_torque_gradient_pos;

    /**
     * The amplitude of torque ripple (1st Harmonic) of the engine.
     *
     * Range: 0..1023 (0..1023 Nm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t engine_torque_ripple;

    /**
     * Signals contained in SAE J1850 CRC8 Checksum: EMCurDcLinkMotorLimit,  EMVolDcLinkMotorLimit and EMMotorLimitGrpCounter.
     * 
     * Signals used in the calculation must be in the same message frame.
     * 
     * The Data Segment Polynomial shall be assembled as follows, with offsets in Motorola Backwards notation :-
     * Byte 1 is the leftmost byte in SAEJ1850 Table 1.
     * 
     * Byte 1
     * 
     * Signal marker         Signal name                    Offset
     * ===========        ==========                   =====
     * A                        EMCurDcLinkMotorLimit        0 (most significant 8 bits)
     * 
     * Byte 2
     * 
     * Signal marker         Signal name                                                         Offset
     * ===========        ==========                                                        =====
     * A                        EMCurDcLinkMotorLimit ( least significant 1 bit)    7
     * B                        EMMotorLimitGrpCounter.                                              3
     * C                        EMVolDcLinkMotorLimit (most significant 3 bits)   0
     * 
     * Byt
     *
     * Range: 0..255 (0..255 checksum)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_motor_limit_grp_cs;

    /**
     * Negative Torque Gradient for BISG
     *
     * Range: 127..0 (-1270..0 Nm/s)
     * Scale: -10
     * Offset: 0
     */
    uint8_t em_torque_gradient_neg;

    /**
     * Instantaneous maximum DC Link current that can be taken during motoring mode derived from battery power limits, not to overload HV battery in motor mode. Current is positive in motoring mode.
     *
     * Range: 0..509 (0..509 Amps)
     * Scale: 1
     * Offset: 0
     */
    uint16_t em_cur_dc_link_motor_limit;

    /**
     * Used to ensure that the PCM is still in active communications with its Micro controller.
     * 
     * Value to increment with each new message sent.
     * 
     * Value initialises at 0 and Increases to 15 at which point the signal is reset to 0 and begins counting up again.
     * 
     * Value initialises to 0.
     * 
     * Stuck count also indicates a fault.
     *
     * Range: 0..15 (0..15 N = E (modulo 16). One increment)
     * Scale: 1
     * Offset: 0
     */
    uint8_t em_motor_limit_grp_counter;

    /**
     * Instantaneous minimum  DC Link voltage allowed in motoring mode so as not to go below the HV battery low voltage limit
     *
     * Range: 0..1021 (0..1021 Volts)
     * Scale: 1
     * Offset: 0
     */
    uint16_t em_vol_dc_link_motor_limit;
};

/**
 * Signals in message PCM_PMZ_X_MHEV.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_pcm_pmz_x_mhev_t {
    /**
     * Controls Engine Stop Assist (BISG) - Machine end speed for ESA mode
     *
     * Range: 0..127 (0..1270 rpm)
     * Scale: 10
     * Offset: 0
     */
    uint8_t em_end_speed_esa;

    /**
     * Controls Engine Stop Assist (BISG) - Maximum duration of ESA
     *
     * Range: 0..31 (0..3.1 s)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t em_duration_max_esa;

    /**
     * Controls Engine Stop Assist (BISG) - Torque limitation set point in ESA mode
     *
     * Range: 63..0 (-63..0 Nm)
     * Scale: -1
     * Offset: 0
     */
    uint8_t em_torque_limit_esa;

    /**
     * Controls Engine Stop Assist (BISG) - Negative torque gradient during Negative Torque control operation
     *
     * Range: 1023..0 (-10230..0 rpm/s)
     * Scale: -10
     * Offset: 0
     */
    uint16_t em_speed_gradient_esa;
};

/**
 * Signals in message UDS_DIAG_Fun_Req.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_uds_diag_fun_req_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t dummy_signal;
};

/**
 * Signals in message UDS_DIAG_Phy_Req.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_uds_diag_phy_req_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t dummy_signal;
};

/**
 * Signals in message VEHCONFIG_400PMZ_AutoSAR.
 *
 * All signal values are as on the CAN bus.
 */
struct x8578_can_db_client_vehconfig_400_pmz_auto_sar_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sf_vehconfig_400_pmz_auto_sar_pdu;

    /**
     * Range: 0..72057594037927900 (0..7.20575940379279E+16 -)
     * Scale: 1
     * Offset: 0
     */
    uint64_t ccf_vin_part2;

    /**
     * Range: 0..281474976710655 (0..281474976710655 -)
     * Scale: 1
     * Offset: 0
     */
    uint64_t ccf_vin_part3;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t ccf_dd00_global_real_time;

    /**
     * Range: 0..16777215 (0..16777215 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t ccf_dd01_total_distance;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t ccf_vin_part1;

    /**
     * Range: 0..255 (-40..215 Deg C)
     * Scale: 1
     * Offset: -40
     */
    uint8_t ccf_dd04_in_car_temp;

    /**
     * Range: 6..14 (6..14 Unused)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ccf_mild_hybrid_type;

    /**
     * Range: 0..255 (0..63.75 Volts)
     * Scale: 0.25
     * Offset: 0
     */
    uint8_t ccf_dd02_main_ecu_sup_volts;

    /**
     * Range: 0..255 (-40..215 Deg C)
     * Scale: 1
     * Offset: -40
     */
    uint8_t ccf_dd05_outdoor_temp;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ccf_dd06_power_mode_pkt;
};

/**
 * Pack message EPIC_PMZ_K.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_epic_pmz_k_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_epic_pmz_k_t *src_p,
    size_t size);

/**
 * Unpack message EPIC_PMZ_K.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_epic_pmz_k_unpack(
    struct x8578_can_db_client_epic_pmz_k_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t x8578_can_db_client_epic_pmz_k_bisg_calibration_id02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_k_bisg_calibration_id02_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_k_bisg_calibration_id02_is_in_range(uint64_t value);

/**
 * Pack message EPIC_PMZ_L.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_epic_pmz_l_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_epic_pmz_l_t *src_p,
    size_t size);

/**
 * Unpack message EPIC_PMZ_L.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_epic_pmz_l_unpack(
    struct x8578_can_db_client_epic_pmz_l_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t x8578_can_db_client_epic_pmz_l_bisg_calib_verif_number_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_l_bisg_calib_verif_number_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_l_bisg_calib_verif_number_is_in_range(uint32_t value);

/**
 * Pack message EPIC_PMZ_J.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_epic_pmz_j_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_epic_pmz_j_t *src_p,
    size_t size);

/**
 * Unpack message EPIC_PMZ_J.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_epic_pmz_j_unpack(
    struct x8578_can_db_client_epic_pmz_j_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t x8578_can_db_client_epic_pmz_j_bisg_calibration_id01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_j_bisg_calibration_id01_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_j_bisg_calibration_id01_is_in_range(uint64_t value);

/**
 * Pack message EPIC_PMZ_I.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_epic_pmz_i_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_epic_pmz_i_t *src_p,
    size_t size);

/**
 * Unpack message EPIC_PMZ_I.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_epic_pmz_i_unpack(
    struct x8578_can_db_client_epic_pmz_i_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t x8578_can_db_client_epic_pmz_i_bisg_diagnostic01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_i_bisg_diagnostic01_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_i_bisg_diagnostic01_is_in_range(uint32_t value);

/**
 * Pack message PCM_PMZ_V_MHEV.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_pcm_pmz_v_mhev_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_pcm_pmz_v_mhev_t *src_p,
    size_t size);

/**
 * Unpack message PCM_PMZ_V_MHEV.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_pcm_pmz_v_mhev_unpack(
    struct x8578_can_db_client_pcm_pmz_v_mhev_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_v_mhev_engine_torq_act_qf_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_v_mhev_engine_torq_act_qf_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_v_mhev_engine_torq_act_qf_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_v_mhev_k0_mode_request_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_v_mhev_k0_mode_request_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_v_mhev_k0_mode_request_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_v_mhev_engine_start_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_v_mhev_engine_start_torque_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_v_mhev_engine_start_torque_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_v_mhev_drvline_damp_enbl_flg_md1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_v_mhev_drvline_damp_enbl_flg_md1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_v_mhev_drvline_damp_enbl_flg_md1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_v_mhev_engine_torq_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_v_mhev_engine_torq_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_v_mhev_engine_torq_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_v_mhev_engine_torq_act_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_v_mhev_engine_torq_act_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_v_mhev_engine_torq_act_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_v_mhev_engine_torq_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_v_mhev_engine_torq_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_v_mhev_engine_torq_checksum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_v_mhev_slip_start_type_request_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_v_mhev_slip_start_type_request_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_v_mhev_slip_start_type_request_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_v_mhev_engine_torq_tgt_wo_trans_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_v_mhev_engine_torq_tgt_wo_trans_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_v_mhev_engine_torq_tgt_wo_trans_is_in_range(uint16_t value);

/**
 * Pack message EPIC_PMZ_A.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_epic_pmz_a_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_epic_pmz_a_t *src_p,
    size_t size);

/**
 * Unpack message EPIC_PMZ_A.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_epic_pmz_a_unpack(
    struct x8578_can_db_client_epic_pmz_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_a_inverter_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_a_inverter_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_a_inverter_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_a_inverter_hvil_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_a_inverter_hvil_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_a_inverter_hvil_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_a_inv_active_short_circuit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_a_inv_active_short_circuit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_a_inv_active_short_circuit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_a_epic_pump_diag_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_a_epic_pump_diag_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_a_epic_pump_diag_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_a_epic_chrg_em_pump_diag_stat_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_a_epic_chrg_em_pump_diag_stat_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_a_epic_chrg_em_pump_diag_stat_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_epic_pmz_a_em_voltage_dc_link_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_a_em_voltage_dc_link_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_a_em_voltage_dc_link_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_a_em_operating_mode_ext_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_a_em_operating_mode_ext_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_a_em_operating_mode_ext_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_a_em_op_mode_ext_gp_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_a_em_op_mode_ext_gp_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_a_em_op_mode_ext_gp_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_a_emacoc_monitor_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_a_emacoc_monitor_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_a_emacoc_monitor_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_a_rapid_dschrg_diag_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_a_rapid_dschrg_diag_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_a_rapid_dschrg_diag_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_epic_pmz_a_em_voltage_dc_link_ext_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_a_em_voltage_dc_link_ext_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_a_em_voltage_dc_link_ext_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_a_em_op_mode_ext_gp_cs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_a_em_op_mode_ext_gp_cs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_a_em_op_mode_ext_gp_cs_is_in_range(uint8_t value);

/**
 * Pack message EPIC_PMZ_C.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_epic_pmz_c_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_epic_pmz_c_t *src_p,
    size_t size);

/**
 * Unpack message EPIC_PMZ_C.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_epic_pmz_c_unpack(
    struct x8578_can_db_client_epic_pmz_c_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_c_em_speed_qf_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_c_em_speed_qf_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_c_em_speed_qf_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_c_em_torq_speed_ext_gp_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_c_em_torq_speed_ext_gp_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_c_em_torq_speed_ext_gp_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_epic_pmz_c_drvline_damp_torque_delta_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_c_drvline_damp_torque_delta_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_c_drvline_damp_torque_delta_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_epic_pmz_c_em_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_c_em_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_c_em_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_c_em_torq_speed_ext_gp_cs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_c_em_torq_speed_ext_gp_cs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_c_em_torq_speed_ext_gp_cs_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_epic_pmz_c_em_torque_ext_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_c_em_torque_ext_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_c_em_torque_ext_is_in_range(uint16_t value);

/**
 * Pack message EPIC_PMZ_E.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_epic_pmz_e_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_epic_pmz_e_t *src_p,
    size_t size);

/**
 * Unpack message EPIC_PMZ_E.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_epic_pmz_e_unpack(
    struct x8578_can_db_client_epic_pmz_e_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_epic_pmz_e_em_current_dc_link_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_e_em_current_dc_link_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_e_em_current_dc_link_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_e_toc_pump_diag_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_e_toc_pump_diag_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_e_toc_pump_diag_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_e_inv_start_current_derate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_e_inv_start_current_derate_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_e_inv_start_current_derate_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_e_inv_short_time_cur_derate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_e_inv_short_time_cur_derate_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_e_inv_short_time_cur_derate_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_e_epicmil_request_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_e_epicmil_request_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_e_epicmil_request_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_e_em_pump_diag_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_e_em_pump_diag_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_e_em_pump_diag_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_e_inv_temperature_derate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_e_inv_temperature_derate_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_e_inv_temperature_derate_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_epic_pmz_e_em_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_e_em_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_e_em_temperature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_epic_pmz_e_em_rotor_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_e_em_rotor_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_e_em_rotor_temperature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_e_temperature_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_e_temperature_rate_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_e_temperature_rate_is_in_range(uint8_t value);

/**
 * Pack message EPIC_PMZ_G.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_epic_pmz_g_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_epic_pmz_g_t *src_p,
    size_t size);

/**
 * Unpack message EPIC_PMZ_G.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_epic_pmz_g_unpack(
    struct x8578_can_db_client_epic_pmz_g_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_g_em_torq_limit_gp_cs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_g_em_torq_limit_gp_cs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_g_em_torq_limit_gp_cs_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_g_em_torq_limit_gp_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_g_em_torq_limit_gp_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_g_em_torq_limit_gp_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_epic_pmz_g_em_min_torque_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_g_em_min_torque_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_g_em_min_torque_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_epic_pmz_g_em_min_cont_torque_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_g_em_min_cont_torque_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_g_em_min_cont_torque_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_epic_pmz_g_em_max_torque_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_g_em_max_torque_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_g_em_max_torque_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_epic_pmz_g_em_max_cont_torque_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_g_em_max_cont_torque_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_g_em_max_cont_torque_limit_is_in_range(uint16_t value);

/**
 * Pack message EPIC_PMZ_H.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_epic_pmz_h_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_epic_pmz_h_t *src_p,
    size_t size);

/**
 * Unpack message EPIC_PMZ_H.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_epic_pmz_h_unpack(
    struct x8578_can_db_client_epic_pmz_h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_epic_pmz_h_em_voltage_dc_link_mv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_h_em_voltage_dc_link_mv_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_h_em_voltage_dc_link_mv_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_h_em_op_mode_mv_gp_cs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_h_em_op_mode_mv_gp_cs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_h_em_op_mode_mv_gp_cs_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_h_em_operating_mode_ext2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_h_em_operating_mode_ext2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_h_em_operating_mode_ext2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_epic_pmz_h_em_op_mode_mv_gp_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_h_em_op_mode_mv_gp_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_h_em_op_mode_mv_gp_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_epic_pmz_h_bisg_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_epic_pmz_h_bisg_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_epic_pmz_h_bisg_speed_is_in_range(uint16_t value);

/**
 * Pack message UDS_DIAG_Resp.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_uds_diag_resp_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_uds_diag_resp_t *src_p,
    size_t size);

/**
 * Unpack message UDS_DIAG_Resp.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_uds_diag_resp_unpack(
    struct x8578_can_db_client_uds_diag_resp_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t x8578_can_db_client_uds_diag_resp_dummy_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_uds_diag_resp_dummy_signal_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_uds_diag_resp_dummy_signal_is_in_range(int8_t value);

/**
 * Pack message BCM_PMZ_A.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_bcm_pmz_a_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_bcm_pmz_a_t *src_p,
    size_t size);

/**
 * Unpack message BCM_PMZ_A.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_bcm_pmz_a_unpack(
    struct x8578_can_db_client_bcm_pmz_a_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_bcm_pmz_a_car_mode_hs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_bcm_pmz_a_car_mode_hs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_bcm_pmz_a_car_mode_hs_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_bcm_pmz_a_car_mode_hs_ub_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_bcm_pmz_a_car_mode_hs_ub_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_bcm_pmz_a_car_mode_hs_ub_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_bcm_pmz_a_power_mode_ub_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_bcm_pmz_a_power_mode_ub_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_bcm_pmz_a_power_mode_ub_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_bcm_pmz_a_power_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_bcm_pmz_a_power_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_bcm_pmz_a_power_mode_is_in_range(uint8_t value);

/**
 * Pack message GWM_PMZ_H.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_gwm_pmz_h_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_gwm_pmz_h_t *src_p,
    size_t size);

/**
 * Unpack message GWM_PMZ_H.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_gwm_pmz_h_unpack(
    struct x8578_can_db_client_gwm_pmz_h_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_gwm_pmz_h_crash_status_rcm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_gwm_pmz_h_crash_status_rcm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_gwm_pmz_h_crash_status_rcm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_gwm_pmz_h_crash_status_rcm_ub_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_gwm_pmz_h_crash_status_rcm_ub_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_gwm_pmz_h_crash_status_rcm_ub_is_in_range(uint8_t value);

/**
 * Pack message PCM_PMZ_AC_MHEV.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_pcm_pmz_ac_mhev_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_pcm_pmz_ac_mhev_t *src_p,
    size_t size);

/**
 * Unpack message PCM_PMZ_AC_MHEV.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_pcm_pmz_ac_mhev_unpack(
    struct x8578_can_db_client_pcm_pmz_ac_mhev_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_ac_mhev_em_voltage_dc_link_req_mv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_ac_mhev_em_voltage_dc_link_req_mv_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_ac_mhev_em_voltage_dc_link_req_mv_is_in_range(uint16_t value);

/**
 * Pack message PCM_PMZ_F_Hybrid.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_pcm_pmz_f_hybrid_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_pcm_pmz_f_hybrid_t *src_p,
    size_t size);

/**
 * Unpack message PCM_PMZ_F_Hybrid.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_pcm_pmz_f_hybrid_unpack(
    struct x8578_can_db_client_pcm_pmz_f_hybrid_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_f_hybrid_vscem_req_gp_cs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_f_hybrid_vscem_req_gp_cs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_f_hybrid_vscem_req_gp_cs_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_f_hybrid_vscem_req_gp_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_f_hybrid_vscem_req_gp_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_f_hybrid_vscem_req_gp_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_f_hybrid_em_operating_mode_req_ext_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_f_hybrid_em_operating_mode_req_ext_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_f_hybrid_em_operating_mode_req_ext_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_f_hybrid_em_voltage_dc_link_req_ext_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_f_hybrid_em_voltage_dc_link_req_ext_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_f_hybrid_em_voltage_dc_link_req_ext_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_f_hybrid_em_speed_request_ext_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_f_hybrid_em_speed_request_ext_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_f_hybrid_em_speed_request_ext_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_f_hybrid_em_torque_request_ext_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_f_hybrid_em_torque_request_ext_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_f_hybrid_em_torque_request_ext_is_in_range(uint16_t value);

/**
 * Pack message PCM_PMZ_T_MHEV.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_pcm_pmz_t_mhev_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_pcm_pmz_t_mhev_t *src_p,
    size_t size);

/**
 * Unpack message PCM_PMZ_T_MHEV.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_pcm_pmz_t_mhev_unpack(
    struct x8578_can_db_client_pcm_pmz_t_mhev_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_t_mhev_toc_pump_dr_req_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_t_mhev_toc_pump_dr_req_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_t_mhev_toc_pump_dr_req_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_t_mhev_em_coolant_pump_dr_req_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_t_mhev_em_coolant_pump_dr_req_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_t_mhev_em_coolant_pump_dr_req_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_t_mhev_em_cur_dc_link_gen_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_t_mhev_em_cur_dc_link_gen_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_t_mhev_em_cur_dc_link_gen_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_t_mhev_em_gen_limit_grp_cs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_t_mhev_em_gen_limit_grp_cs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_t_mhev_em_gen_limit_grp_cs_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_t_mhev_em_gen_limit_grp_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_t_mhev_em_gen_limit_grp_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_t_mhev_em_gen_limit_grp_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_t_mhev_em_vol_dc_link_gen_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_t_mhev_em_vol_dc_link_gen_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_t_mhev_em_vol_dc_link_gen_limit_is_in_range(uint16_t value);

/**
 * Pack message PCM_PMZ_U_MHEV.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_pcm_pmz_u_mhev_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_pcm_pmz_u_mhev_t *src_p,
    size_t size);

/**
 * Unpack message PCM_PMZ_U_MHEV.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_pcm_pmz_u_mhev_unpack(
    struct x8578_can_db_client_pcm_pmz_u_mhev_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_u_mhev_vscem_torq_lim_gp_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_u_mhev_vscem_torq_lim_gp_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_u_mhev_vscem_torq_lim_gp_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_u_mhev_em_torque_min_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_u_mhev_em_torque_min_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_u_mhev_em_torque_min_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_u_mhev_em_torque_max_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_u_mhev_em_torque_max_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_u_mhev_em_torque_max_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_u_mhev_drvline_damp_torq_min_lim_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_u_mhev_drvline_damp_torq_min_lim_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_u_mhev_drvline_damp_torq_min_lim_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_u_mhev_drvline_damp_torq_max_lim_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_u_mhev_drvline_damp_torq_max_lim_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_u_mhev_drvline_damp_torq_max_lim_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_u_mhev_vscem_torq_lim_gp_cs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_u_mhev_vscem_torq_lim_gp_cs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_u_mhev_vscem_torq_lim_gp_cs_is_in_range(uint8_t value);

/**
 * Pack message PCM_PMZ_W_MHEV.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_pcm_pmz_w_mhev_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_pcm_pmz_w_mhev_t *src_p,
    size_t size);

/**
 * Unpack message PCM_PMZ_W_MHEV.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_pcm_pmz_w_mhev_unpack(
    struct x8578_can_db_client_pcm_pmz_w_mhev_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_w_mhev_bisg_calibration_id_req_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_w_mhev_bisg_calibration_id_req_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_w_mhev_bisg_calibration_id_req_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_w_mhev_em_torque_gradient_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_w_mhev_em_torque_gradient_pos_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_w_mhev_em_torque_gradient_pos_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_w_mhev_engine_torque_ripple_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_w_mhev_engine_torque_ripple_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_w_mhev_engine_torque_ripple_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_w_mhev_em_motor_limit_grp_cs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_w_mhev_em_motor_limit_grp_cs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_w_mhev_em_motor_limit_grp_cs_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_w_mhev_em_torque_gradient_neg_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_w_mhev_em_torque_gradient_neg_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_w_mhev_em_torque_gradient_neg_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_w_mhev_em_cur_dc_link_motor_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_w_mhev_em_cur_dc_link_motor_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_w_mhev_em_cur_dc_link_motor_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_w_mhev_em_motor_limit_grp_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_w_mhev_em_motor_limit_grp_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_w_mhev_em_motor_limit_grp_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_w_mhev_em_vol_dc_link_motor_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_w_mhev_em_vol_dc_link_motor_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_w_mhev_em_vol_dc_link_motor_limit_is_in_range(uint16_t value);

/**
 * Pack message PCM_PMZ_X_MHEV.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_pcm_pmz_x_mhev_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_pcm_pmz_x_mhev_t *src_p,
    size_t size);

/**
 * Unpack message PCM_PMZ_X_MHEV.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_pcm_pmz_x_mhev_unpack(
    struct x8578_can_db_client_pcm_pmz_x_mhev_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_x_mhev_em_end_speed_esa_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_x_mhev_em_end_speed_esa_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_x_mhev_em_end_speed_esa_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_x_mhev_em_duration_max_esa_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_x_mhev_em_duration_max_esa_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_x_mhev_em_duration_max_esa_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_pcm_pmz_x_mhev_em_torque_limit_esa_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_x_mhev_em_torque_limit_esa_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_x_mhev_em_torque_limit_esa_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t x8578_can_db_client_pcm_pmz_x_mhev_em_speed_gradient_esa_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_pcm_pmz_x_mhev_em_speed_gradient_esa_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_pcm_pmz_x_mhev_em_speed_gradient_esa_is_in_range(uint16_t value);

/**
 * Pack message UDS_DIAG_Fun_Req.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_uds_diag_fun_req_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_uds_diag_fun_req_t *src_p,
    size_t size);

/**
 * Unpack message UDS_DIAG_Fun_Req.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_uds_diag_fun_req_unpack(
    struct x8578_can_db_client_uds_diag_fun_req_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t x8578_can_db_client_uds_diag_fun_req_dummy_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_uds_diag_fun_req_dummy_signal_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_uds_diag_fun_req_dummy_signal_is_in_range(int8_t value);

/**
 * Pack message UDS_DIAG_Phy_Req.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_uds_diag_phy_req_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_uds_diag_phy_req_t *src_p,
    size_t size);

/**
 * Unpack message UDS_DIAG_Phy_Req.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_uds_diag_phy_req_unpack(
    struct x8578_can_db_client_uds_diag_phy_req_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t x8578_can_db_client_uds_diag_phy_req_dummy_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_uds_diag_phy_req_dummy_signal_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_uds_diag_phy_req_dummy_signal_is_in_range(int8_t value);

/**
 * Pack message VEHCONFIG_400PMZ_AutoSAR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int x8578_can_db_client_vehconfig_400_pmz_auto_sar_pack(
    uint8_t *dst_p,
    const struct x8578_can_db_client_vehconfig_400_pmz_auto_sar_t *src_p,
    size_t size);

/**
 * Unpack message VEHCONFIG_400PMZ_AutoSAR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int x8578_can_db_client_vehconfig_400_pmz_auto_sar_unpack(
    struct x8578_can_db_client_vehconfig_400_pmz_auto_sar_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_vehconfig_400_pmz_auto_sar_sf_vehconfig_400_pmz_auto_sar_pdu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_vehconfig_400_pmz_auto_sar_sf_vehconfig_400_pmz_auto_sar_pdu_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_vehconfig_400_pmz_auto_sar_sf_vehconfig_400_pmz_auto_sar_pdu_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_vin_part2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_vin_part2_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_vin_part2_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_vin_part3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_vin_part3_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_vin_part3_is_in_range(uint64_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd00_global_real_time_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd00_global_real_time_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd00_global_real_time_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd01_total_distance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd01_total_distance_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd01_total_distance_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_vin_part1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_vin_part1_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_vin_part1_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd04_in_car_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd04_in_car_temp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd04_in_car_temp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_mild_hybrid_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_mild_hybrid_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_mild_hybrid_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd02_main_ecu_sup_volts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd02_main_ecu_sup_volts_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd02_main_ecu_sup_volts_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd05_outdoor_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd05_outdoor_temp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd05_outdoor_temp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd06_power_mode_pkt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd06_power_mode_pkt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool x8578_can_db_client_vehconfig_400_pmz_auto_sar_ccf_dd06_power_mode_pkt_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
